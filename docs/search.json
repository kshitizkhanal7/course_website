[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "basic_data_wrangling.html",
    "href": "basic_data_wrangling.html",
    "title": "Basic data wrangling",
    "section": "",
    "text": "Grouping and summarizing data\nWhat if we wanted to figure out monthly average temperature?\n\nmonthly_aq <- aq_df |>\n  mutate(date_2020 = as.Date(date_2020)) |> #converting chr class to Date class\n  mutate(month = month(date_2020)) |> # using month() from lubridate package\n  group_by(month) |> \n  na.omit() |>\n  summarise(avg_temp = mean(temperature))\n\nhead(monthly_aq)\n\n# A tibble: 6 × 2\n  month avg_temp\n  <dbl>    <dbl>\n1     1     69.2\n2     2     76.7\n3     3     81.7\n4     4     70.7\n5     5     71.1\n6     6     78.6\n\n\nExercise: Try grouping by two variables, month and ID (represents different sensors), and summarize by mean of average temperature and median of air quality."
  },
  {
    "objectID": "data_wrangling_continued.html",
    "href": "data_wrangling_continued.html",
    "title": "Data wrangling (continued)",
    "section": "",
    "text": "You have already used several functions. mutate(), mean(), summarize(), etc. are all functions developed for base R or other specific packages like tidyverse. Functions simplify analytics process by making code more readable and concise.\nWe can develop our own functions in R. Functions are particularly useful when we need to do the same operation multiple times. Instead of copying and pasting code every time we repeat an operation, we can write a function.\nFrom : Writing a function has three big advantages over using copy-and-paste (R for Data Science, 2e):\n\nYou can give a function an evocative name that makes your code easier to understand.\nAs requirements change, you only need to update code in one place, instead of many.\nYou eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).\nIt makes it easier to reuse work from project-to-project, increasing your productivity over time.\n\n\n\nSuppose we want to create a function that takes a number as input, and returns the square of that number as output. Here’s how we would write the function in R.\n\nget_squared <- function(num) {\n  return (num * num)\n}\n\nget_squared(5)\n## [1] 25\nget_squared(10)\n## [1] 100\n\nExplanation:\n\nget_squared is the name of the function. It should ideally tell us what the function does concisely and follow good variable naming practices we discussed earlier.\nfunction() is the syntax to create functions.\nnum is a input to the function. Function inputs are called parameters.\nreturn specifies what the function returns as output. Not all functions have return statements, we will deal with them later in the course.\nto use the function, we write function name with inputs within the brackets as we did for get_squared(5)\n\n\n\n\nWe will work on a data of sports arenas\n\nlibrary(tidyverse)\n\nsport <- c(\"soccer\", \"football\", \"baseball\", \"basketball\", \"hockey\", \"tennis\")\nlength <- c(100, 120, 90, 94, 200, 78)\nwidth <- c(64, 53.3, 27, 50, 85, 36)\nfield_df <- data.frame(sport, length, width)\nfield_df\n##        sport length width\n## 1     soccer    100  64.0\n## 2   football    120  53.3\n## 3   baseball     90  27.0\n## 4 basketball     94  50.0\n## 5     hockey    200  85.0\n## 6     tennis     78  36.0\n\n#define a function to calculate area\narea_field <- function (length, width) {\n  return (length * width)\n}\n\n# use mutate to create a new column using the area_field function\nfield_df <- field_df %>% \n  mutate(area = area_field(length, width))\n\nhead(field_df)\n##        sport length width  area\n## 1     soccer    100  64.0  6400\n## 2   football    120  53.3  6396\n## 3   baseball     90  27.0  2430\n## 4 basketball     94  50.0  4700\n## 5     hockey    200  85.0 17000\n## 6     tennis     78  36.0  2808\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate dummy data of four places and temperatures (in Fahrenheit). Create a function to convert Fahrenheit temperature to Celsius. Use that function to create a new column of temperature in degree Celsius in your dummy data frame."
  },
  {
    "objectID": "data_wrangling_continued.html#conditionals-if_else",
    "href": "data_wrangling_continued.html#conditionals-if_else",
    "title": "Data wrangling (continued)",
    "section": "Conditionals: if_else",
    "text": "Conditionals: if_else\nIf else conditionals help us operate on data based on certain conditions. Take for example your grades. Your grades are conditioned on your scores and criteria for grading that your instructor sets.\n\nlibrary(tidyverse)\n\n# create dummy dataset\nstudents <- tibble(\n  name = c(\"AB\", \"CS\", \"ST\", \"KK\", \"UB\", \"RW\"),\n  score = c(75, 85, 90, 60, 80, 95)\n)\n\n\nCreating new columns with if_else conditions\n\nstudents <- students %>% \n  mutate(result = if_else(score >= 70, \"Pass\", \"Fail\"))\n\nstudents\n## # A tibble: 6 × 3\n##   name  score result\n##   <chr> <dbl> <chr> \n## 1 AB       75 Pass  \n## 2 CS       85 Pass  \n## 3 ST       90 Pass  \n## 4 KK       60 Fail  \n## 5 UB       80 Pass  \n## 6 RW       95 Pass\n\nAnatomy of if_else:\n\nif_else if a tidyverse function. The base R equivalent is ifelse\nthere are three components inside the bracket:\n\nscore>=70 sets a criteria\n“Pass” is the value of the new column if the criteria is True\n“Fail” is the value of the new column if the criteria is False\n\n\n\n\nAdding multiple conditions\n\nstudents <- students %>% \n  mutate(\n    grade = case_when(\n      score >= 90 ~ \"A\",\n      score >= 80 ~ \"B\",\n      score >= 70 ~ \"C\",\n      score >= 60 ~ \"D\",\n      TRUE ~ \"F\"\n    )\n  )\n\nstudents\n## # A tibble: 6 × 4\n##   name  score result grade\n##   <chr> <dbl> <chr>  <chr>\n## 1 AB       75 Pass   C    \n## 2 CS       85 Pass   B    \n## 3 ST       90 Pass   A    \n## 4 KK       60 Fail   D    \n## 5 UB       80 Pass   B    \n## 6 RW       95 Pass   A\n\nif_else is useful when we have only one condition that can be True or False. When we have multiple possible outputs for different conditions, we can use case_when.\nExercise: I wrote a process to generate dummy data of customers of an imaginary store based on the following code.\n\n# create dummy data\nset.seed(123) #ensures reproducibility\n\ncustomer <- paste0(\"Customer\", 1:10)\nage <- sample(18:65, 10, replace = TRUE)\ngender <- sample(c(\"Male\", \"Female\"), 10, replace = TRUE)\nincome <- sample(25000:100000, 10, replace = TRUE)\nspending_2020 <- sample(1000:5000, 10, replace = TRUE)\nspending_2021 <- sample(1000:5000, 10, replace = TRUE)\n\n# combine into a data frame\ncustomer_data <- data.frame(customer, age, gender, income, spending_2020, spending_2021)\n\n# view data frame\ncustomer_data\n##      customer age gender income spending_2020 spending_2021\n## 1   Customer1  48   Male  60655          2247          4936\n## 2   Customer2  32 Female  92149          1165          3906\n## 3   Customer3  31   Male  74706          1216          1152\n## 4   Customer4  20   Male  45852          2313          1293\n## 5   Customer5  59   Male  99894          3628          1276\n## 6   Customer6  60   Male  34990          3119          2486\n## 7   Customer7  54 Female  40272          1587          1040\n## 8   Customer8  31   Male  28003          2598          3478\n## 9   Customer9  42   Male  77358          1140          3137\n## 10 Customer10  43   Male  61762          1721          1315\n\nPerform the following:\n\nCreate a new variable called Total spending that is the sum of spending in 2020 and 2021\nUse an ifelse() statement and the mutate() function to create a new variable called Frequent shopper that is equal to “Yes” if a customer’s total spending is greater than $5000, and “No” otherwise.\nUse the group_by() and summarise() functions to calculate the total number of frequent shoppers by different age groups. Create three age groups based on your own judgment."
  },
  {
    "objectID": "data_wrangling_continued.html#joining-different-datasets",
    "href": "data_wrangling_continued.html#joining-different-datasets",
    "title": "Data wrangling (continued)",
    "section": "Joining different datasets",
    "text": "Joining different datasets\nIt is rare that we will be do most of our analysis using a single dataset. We usually need to combine multiple datasets to seek valuable insights. The process of combining the datasets are known as “joins.” There are various types of joins, but we will focus on the two most commonly used joins in this tutorial.\nWe will get data on population in North Carolina counties from ACS and area of different counties from TIGRIS. We will combine those datasets to be able to estimate population density in those counties.\n\n#install.packages(\"tidycensus\")\nlibrary(tidycensus)\n\n# gets latest ACS data\nnc_counties_pop <- get_acs(\n  geography = \"county\", \n  variables = \"B01003_001\",\n  state = \"NC\") |>\n  rename(population = estimate) |>\n  select(-variable, -moe)\n## Getting data from the 2016-2020 5-year ACS\n\nhead(nc_counties_pop)\n## # A tibble: 6 × 3\n##   GEOID NAME                             population\n##   <chr> <chr>                                 <dbl>\n## 1 37001 Alamance County, North Carolina      166144\n## 2 37003 Alexander County, North Carolina      37271\n## 3 37005 Alleghany County, North Carolina      11085\n## 4 37007 Anson County, North Carolina          24430\n## 5 37009 Ashe County, North Carolina           27009\n## 6 37011 Avery County, North Carolina          17510\n\n\n#install.packages(\"tigris\")\nlibrary(tigris)\noptions(tigris_use_cache = TRUE)\n\nnc_counties_area <- counties(state = \"NC\", cb = TRUE) %>% \n  mutate(area = ALAND + AWATER) %>% \n  select(GEOID, area)\n\n\nhead(nc_counties_area) \n## Simple feature collection with 6 features and 2 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -84.32187 ymin: 34.98659 xmax: -76.01142 ymax: 36.56235\n## Geodetic CRS:  NAD83\n##    GEOID       area                       geometry\n## 92 37039 1208659098 MULTIPOLYGON (((-84.31749 3...\n## 93 37089  971465695 MULTIPOLYGON (((-82.74289 3...\n## 94 37171 1389934523 MULTIPOLYGON (((-80.97364 3...\n## 95 37131 1425923942 MULTIPOLYGON (((-77.90008 3...\n## 97 37177 1546678365 MULTIPOLYGON (((-76.4056 35...\n## 98 37043  571822258 MULTIPOLYGON (((-84.00582 3...\n\nWe can see that there is a common “GEOID” column that we can use to join the dataset.\nThere are few different joins we can use for these datasets.\n\nnc_counties <- inner_join(nc_counties_area, nc_counties_pop)\n## Joining with `by = join_by(GEOID)`\nhead(nc_counties)\n## Simple feature collection with 6 features and 4 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -84.32187 ymin: 34.98659 xmax: -76.01142 ymax: 36.56235\n## Geodetic CRS:  NAD83\n##   GEOID       area                               NAME population\n## 1 37039 1208659098    Cherokee County, North Carolina      28413\n## 2 37089  971465695   Henderson County, North Carolina     116298\n## 3 37171 1389934523       Surry County, North Carolina      71904\n## 4 37131 1425923942 Northampton County, North Carolina      19672\n## 5 37177 1546678365     Tyrrell County, North Carolina       3978\n## 6 37043  571822258        Clay County, North Carolina      11150\n##                         geometry\n## 1 MULTIPOLYGON (((-84.31749 3...\n## 2 MULTIPOLYGON (((-82.74289 3...\n## 3 MULTIPOLYGON (((-80.97364 3...\n## 4 MULTIPOLYGON (((-77.90008 3...\n## 5 MULTIPOLYGON (((-76.4056 35...\n## 6 MULTIPOLYGON (((-84.00582 3...\n\nIt joins the latter dataset (nc_counties_pop) to the nc_counties_area dataset. Since the name of the common variable (GEOID) is same between both datasets, it automatically joins by that variable.\nThe better practice is to make the common variable explicit, in case there are multiple common variables.\n\nnc_counties2 <- inner_join(nc_counties_area, nc_counties_pop, by = \"GEOID\")\nhead(nc_counties2)\n## Simple feature collection with 6 features and 4 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -84.32187 ymin: 34.98659 xmax: -76.01142 ymax: 36.56235\n## Geodetic CRS:  NAD83\n##   GEOID       area                               NAME population\n## 1 37039 1208659098    Cherokee County, North Carolina      28413\n## 2 37089  971465695   Henderson County, North Carolina     116298\n## 3 37171 1389934523       Surry County, North Carolina      71904\n## 4 37131 1425923942 Northampton County, North Carolina      19672\n## 5 37177 1546678365     Tyrrell County, North Carolina       3978\n## 6 37043  571822258        Clay County, North Carolina      11150\n##                         geometry\n## 1 MULTIPOLYGON (((-84.31749 3...\n## 2 MULTIPOLYGON (((-82.74289 3...\n## 3 MULTIPOLYGON (((-80.97364 3...\n## 4 MULTIPOLYGON (((-77.90008 3...\n## 5 MULTIPOLYGON (((-76.4056 35...\n## 6 MULTIPOLYGON (((-84.00582 3...\n\nDoes it produce the same results?\n\nhead(nc_counties == nc_counties2)\n##      GEOID area NAME population geometry\n## [1,]  TRUE TRUE TRUE       TRUE     TRUE\n## [2,]  TRUE TRUE TRUE       TRUE     TRUE\n## [3,]  TRUE TRUE TRUE       TRUE     TRUE\n## [4,]  TRUE TRUE TRUE       TRUE     TRUE\n## [5,]  TRUE TRUE TRUE       TRUE     TRUE\n## [6,]  TRUE TRUE TRUE       TRUE     TRUE\n\nInner join only returns rows when there is a match.\nWe can use left join when we want all observations of the dataset on the left side, and only the matching observations on the dataset on the right side.\n\nnc_counties3 <- left_join(nc_counties_area, nc_counties_pop, by = \"GEOID\")\nhead(nc_counties3)\n## Simple feature collection with 6 features and 4 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -84.32187 ymin: 34.98659 xmax: -76.01142 ymax: 36.56235\n## Geodetic CRS:  NAD83\n##   GEOID       area                               NAME population\n## 1 37039 1208659098    Cherokee County, North Carolina      28413\n## 2 37089  971465695   Henderson County, North Carolina     116298\n## 3 37171 1389934523       Surry County, North Carolina      71904\n## 4 37131 1425923942 Northampton County, North Carolina      19672\n## 5 37177 1546678365     Tyrrell County, North Carolina       3978\n## 6 37043  571822258        Clay County, North Carolina      11150\n##                         geometry\n## 1 MULTIPOLYGON (((-84.31749 3...\n## 2 MULTIPOLYGON (((-82.74289 3...\n## 3 MULTIPOLYGON (((-80.97364 3...\n## 4 MULTIPOLYGON (((-77.90008 3...\n## 5 MULTIPOLYGON (((-76.4056 35...\n## 6 MULTIPOLYGON (((-84.00582 3...\n\nhead(nc_counties == nc_counties3)\n##      GEOID area NAME population geometry\n## [1,]  TRUE TRUE TRUE       TRUE     TRUE\n## [2,]  TRUE TRUE TRUE       TRUE     TRUE\n## [3,]  TRUE TRUE TRUE       TRUE     TRUE\n## [4,]  TRUE TRUE TRUE       TRUE     TRUE\n## [5,]  TRUE TRUE TRUE       TRUE     TRUE\n## [6,]  TRUE TRUE TRUE       TRUE     TRUE\n\nIn this case, we have all observations matching between the two datasets. Let’s remove 5 observations from the left dataset, and check if that makes any difference.\n\nnc_counties_area_short <- nc_counties_area |> \n  slice(1:95)\n\nnc_counties4 <- left_join(nc_counties_area, nc_counties_pop, by = \"GEOID\")\n\nnrow(nc_counties4)\n## [1] 100\n\nnc_counties5 <- left_join(nc_counties_area_short, nc_counties_pop, by = \"GEOID\")\n\nnrow(nc_counties5)\n## [1] 95\n\nFor the final operation, we only have 95 counties in the table with area. With left join, now we only have 95 rows in the final table.\nIs there a right join? What does it do?\n\nnc_counties6 <- right_join(nc_counties_area_short, nc_counties_pop, by = \"GEOID\")\n\nnrow(nc_counties6)\n## [1] 100\n\nNow, we have all observations in the right dataset and only matching observations from the left dataset, which is why we have 100 observations in the final dataset.\nWe will deal with other types of joins later when we need them. Inner joins and left joins are the most commonly used joins.\nExercise: Using the following tibbles, create inner join between city_population and city_area datasets. Which observations are left out? Create right join between city_density and city employment. Which observations are left out? Write your reflections in a few sentences.\n\ncity_population <- tibble(\n  city = c(\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\", \"Philadelphia\"),\n  population = c(8398748, 3990456, 2705994, 2325502, 1567442)\n)\n\ncity_area <- tibble(\n  city = c(\"New York\", \"Los Angeles\", \"Chicago\", \"Dallas\", \"Phoenix\", \"Philadelphia\"),\n  area = c(468.9, 1302.0, 227.3, 882.9, 1339.6, 347.6)\n)\n\ncity_density <- tibble(\n  city = c(\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\", \"Dallas\", \"Phoenix\", \"Philadelphia\"),\n  density = c(17888, 3072, 11907, 2632, 2635, 1207, 4508)\n)\n\ncity_employment <- tibble(\n  city = c(\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\", \"Phoenix\", \"San Antonio\"),\n  employment_rate = c(57.1, 51.2, 52.3, 61.2, 50.1, 59.8)\n)"
  },
  {
    "objectID": "first_tutorial.html#r-as-a-scientific-calculator",
    "href": "first_tutorial.html#r-as-a-scientific-calculator",
    "title": "Your first tutorial with R and markdown",
    "section": "R as a scientific calculator",
    "text": "R as a scientific calculator\n\nAddition of two numbers\n\n2+2\n## [1] 4\n\n\nExercise: Using regular mathematical symbols (+, -, /, and *), try more complex calculations.\n\n\n\nOther mathematical functions\n\nlog(1)              # logarithm to base e\n## [1] 0\n\nlog10(1)            # logarithm to base 10\n## [1] 0\n\nexp(1)              # natural antilog\n## [1] 2.718282\n\nsqrt(4)             # square root\n## [1] 2\n\n4^2                 # 4 to the power of 2\n## [1] 16\n\npi                  # not a function but useful\n## [1] 3.141593\n\n\n\nCreating, naming, and manipulating objects\nEverything we create or manipulate using R is an object. It can range from a character “a”, a number (1), a dataset, an image, a function, and more. Essentially, all data analysis involves creating and manipulating objects.\nWe use the assignment operator <- to create objects and assign those to object names.\nFor example,\n\na <- 5\n\nWe created an object “a” with value 5. On the top right side of RStudio, you can see a in your “Environment.”\nNow we can perform mathematical operation by manipulating the object a.\n\na * 2\n## [1] 10\n\na + a\n## [1] 10\n\na ^ a\n## [1] 3125\n\nSimilarly,\n\nb <- 10\n\n(a + b) ^ 2\n## [1] 225\n\nObjects that are often known as strings in programming (e.g. words, phrases, etc.) are assigned slightly differently.\n\nstring1 <- \"this is a string\"\nstring1\n## [1] \"this is a string\"\n\nstring2 <- \"this is another string\"\nstring2\n## [1] \"this is another string\"\n\n# joining strings\nstring3 <- paste0(string1, \" \", string2)\nstring3\n## [1] \"this is a string this is another string\"\n\n\nNaming objects (in slides)\n\n\n\nWorking with data\n\nCreating a list of numbers\nc() joins (concatenates) the numbers from one to five to create a vector. A vector in R is essentially a data type that stores numbers or strings.\nThe vector can also be created using : symbol for sequences.\n== is an operator that checks if objects being compared are equal.\n\nmy_vector <- c(1, 2, 3, 4, 5)\nanother_vector <- 1:5\nmy_vector == another_vector\n## [1] TRUE TRUE TRUE TRUE TRUE\n\n\nmy_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)\n\nmean(my_vec)\n## [1] 3.625\n\nlength(my_vec)\n## [1] 8\n\n\nExercise:\nIt’s almost impossible to remember all programming syntax we need. A skill to develop is to find where to look for syntax when you need. You can refer to documentation, online resources like tutorials or books, or in your Integrated Development Environment (here, RStudio).\nUse a search engine (e.g. Google) to find out how you can calculate the standard deviation of “my_vec” in R.\n\n\n\nExtracting values from vectors\n\nWe can use the position of elements in the vectors.\n\nmy_vec[3] #accesses the third element in the vector\n\n[1] 1\n\nmy_vec[2:5] #accesses the second to the fifth elements in the vector\n\n[1] 3 1 6 4\n\n\n\n\nWe can use conditionality\n\nmy_vec[my_vec > 4] #values greater than 4\n\n[1] 6 7\n\nmy_vec[my_vec >2 & my_vec < 8] #values greater than two and less than 8\n\n[1] 3 6 4 3 3 7\n\nmy_vec[my_vec <2 | my_vec > 6] #values less than two or more than 6\n\n[1] 1 7\n\n\n\n\n\nManipulating vectors\n\nReplacing elements\n\nmy_vec[2] <- 100 #replacing the second element by 100\nmy_vec\n\n[1]   2 100   1   6   4   3   3   7\n\n# replace element that are less than or equal to 4 with 1000\nmy_vec[my_vec <= 5] <- 200\nmy_vec\n\n[1] 200 100 200   6 200 200 200   7\n\n\n\n\nVectorization\nWe can apply an operation to all elements of the vectors at the same time. This is known as vectroization, and is very useful in data analysis.\n\n# create a vector\nmy_vec2 <- c(3, 5, 7, 1, 9, 20)\n\n# multiply each element by 5\nmy_vec2 * 5\n\n[1]  15  25  35   5  45 100\n\n\n\n\nMore operations\n\n# create a second vector\nmy_vec3 <- c(17, 15, 13, 19, 11, 0)\n\n# add both vectors\nmy_vec2 + my_vec3\n\n[1] 20 20 20 20 20 20\n\n# multiply both vectors\nmy_vec2 * my_vec3\n\n[1] 51 75 91 19 99  0\n\n# sort vector by values\nvec_sort <- sort(my_vec)\n\n# sort in descending order\nvec_sort2 <- sort(my_vec, decreasing = TRUE)\nvec_sort2\n\n[1] 200 200 200 200 200 100   7   6\n\n# reverse a vector\nrev_vec <- rev(my_vec)\nrev_vec\n\n[1]   7 200 200 200   6 200 100 200\n\n\n\n\nMissing data\nNA or not available is a common symbol to represent missingness in R.\n\ntemp  <- c(7.2, NA, 7.1, 6.9, 6.5, 5.8, 5.8, 5.5, NA, 5.5)\ntemp\n\n [1] 7.2  NA 7.1 6.9 6.5 5.8 5.8 5.5  NA 5.5\n\n#calculate mean\nmean_temp <- mean(temp)\nmean_temp\n\n[1] NA\n\n\nIt resulted in NA as mean because mathematical operations cannot be performed with NA values. We can remove NA using na.rm=TRUE\n\nmean_temp <- mean(temp, na.rm = TRUE)\nmean_temp\n\n[1] 6.2875\n\n\n\n\n\n\nImporting data from csv files\nWhile creating and manipulating vectors have been useful for learning fundamental concepts, we mostly work with existing dataset.\n\n# downloading data on E-ZPass Retailers Locations from NY Open Data portal using web link (URL)\ndf1 <- read.csv(\"https://data.ny.gov/api/views/y59h-w6v4/rows.csv?accessType=DOWNLOAD&sorting=true\")\nhead(df1)\n\n                              Company              Street.1  Street.2     City\n1                      DMV-HARLEM MVO 159 EAST 125TH STREET 3RD FLOOR NEW YORK\n2 COMMUNITY FINANCIAL SERVICE CENTERS   112 TOMPKINS AVENUE           BROOKLYN\n3 COMMUNITY FINANCIAL SERVICE CENTERS 1629 LEXINGTON AVENUE           NEW YORK\n4 COMMUNITY FINANCIAL SERVICE CENTERS    523 FLUSHING VENUE           BROOKLYN\n5             NYC TRANSIT MUSEUM SHOP            2 BROADWAY           NEW YORK\n6 COMMUNITY FINANCIAL SERVICE CENTERS   677 ALLERTON AVENUE              BRONX\n  State Zip.Code                 Georeference\n1    NY    10035 POINT (-73.936625 40.804046)\n2    NY    11206 POINT (-73.946317 40.695389)\n3    NY    10029  POINT (-73.94778 40.790199)\n4    NY    11205                             \n5    NY    10004  POINT (-74.01329 40.704474)\n6    NY    10467 POINT (-73.868069 40.865418)\n\n\nDownloading from your project directory\n\ndf2 <- read.csv(\"retailers_locations.csv\")\nhead(df2)\n\n                              Company              Street.1  Street.2     City\n1                      DMV-HARLEM MVO 159 EAST 125TH STREET 3RD FLOOR NEW YORK\n2 COMMUNITY FINANCIAL SERVICE CENTERS   112 TOMPKINS AVENUE           BROOKLYN\n3 COMMUNITY FINANCIAL SERVICE CENTERS 1629 LEXINGTON AVENUE           NEW YORK\n4 COMMUNITY FINANCIAL SERVICE CENTERS    523 FLUSHING VENUE           BROOKLYN\n5             NYC TRANSIT MUSEUM SHOP            2 BROADWAY           NEW YORK\n6 COMMUNITY FINANCIAL SERVICE CENTERS   677 ALLERTON AVENUE              BRONX\n  State Zip.Code                 Georeference\n1    NY    10035 POINT (-73.936625 40.804046)\n2    NY    11206 POINT (-73.946317 40.695389)\n3    NY    10029  POINT (-73.94778 40.790199)\n4    NY    11205                             \n5    NY    10004  POINT (-74.01329 40.704474)\n6    NY    10467 POINT (-73.868069 40.865418)\n\n\n\n\nAdd image in markdown document\nCopy the code between the inverted commas in the markdown document, not in the code chunk!\n\n\"\n![R logo](https://www.r-project.org/Rlogo.png)\n\"\n\n[1] \"\\n![R logo](https://www.r-project.org/Rlogo.png)\\n\"\n\n\n\n\n\nR logo\n\n\n\n\nExercise: Download an image from the internet into your project directory. Embed that to the markdown."
  },
  {
    "objectID": "first_tutorial.html#lab-submission",
    "href": "first_tutorial.html#lab-submission",
    "title": "Your first tutorial with R and markdown",
    "section": "Lab submission",
    "text": "Lab submission\nTo submit the lab, zip qmd file, html file, and the folder that has contents for html files into a single zipped folder and submit as your lab."
  }
]